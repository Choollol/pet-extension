#include <fstream>
#include <string>
#include <vector>

#include "ToolUtil.hpp"

/*
ADDING NEW PET PROPERTY:
1 - Add new variable to PetData struct
2 - Write property inside generatePetData()
3 - Add property to SinglePetData in generateSpriteDataTypes()
4 - Update petData in main()
*/

/*
ADDING NEW PET:
1 - Create a folder in pet_sprites and subfolders for types of movement, and add the sprite images
2 - Add a new entry to the petData vector in main()
3 - Re-generate pet data
*/

const unsigned DEFAULT_ACTIVE_LEVEL = 2;
const unsigned DEFAULT_MOVE_SPEED = 20;
const unsigned DEFAULT_FRAME_LENGTH_MS = 1000;

struct PetData {
    std::string internalName;
    std::string externalName;
    unsigned idleSpriteCount;
    unsigned moveSpriteCount;
    std::string thumbnailSprite;
    unsigned activeLevel = DEFAULT_ACTIVE_LEVEL;  // Range: 0-5
    unsigned idleFrameLengthMs = DEFAULT_FRAME_LENGTH_MS;
    unsigned moveFrameLengthMs = DEFAULT_FRAME_LENGTH_MS;
    unsigned moveSpeed = DEFAULT_MOVE_SPEED;
};

char thumbnailSeparator = ' ';

void generatePetData(const std::string& outputDir, const std::string& fileName, const std::string& fileExtension, const std::vector<PetData>& petData);

int main() {
    std::string outputDir = "../assets/data";

    std::vector<PetData> petData = {
        {"testPet", "Test Pet", 2, 2, "idle 1", 5},
        {"slime", "The Witch's Slime", 2, 2, "idle 2", 3},
        {
            "snowFox",
            "Crystal Fox",
            2,
            4,
            "idle 1",
            2,
            3000,
            500,
        },
    };

    generatePetData(outputDir, "pet-data", "ts", petData);
}

template <typename T>
void generateObjectProperty(std::ofstream& writer, unsigned indentationAmount, std::string key, T value, bool isString = false);

/**
 * @param spriteType Should be in lowercase. Example: "idle"
 */
void generateSpritePaths(std::ofstream& writer, const PetData& pet, const std::string& spriteType, int spriteCount);

/**
 * Generates a single sprite path
 */
std::string getSpritePath(const PetData& pet, const std::string& spriteType, int frameNumber);

void generateSpriteDataTypes(std::ofstream& writer);

void generatePetData(const std::string& outputDir, const std::string& fileName, const std::string& fileExtension, const std::vector<PetData>& petData) {
    std::string path = outputDir + "/" + fileName + "." + fileExtension;

    std::ofstream writer(path);

    writer << "// Generated by tool/GenerateData\n\n";

    generateSpriteDataTypes(writer);

    writer << "export const petData: { [petName: string]: SinglePetData } = {\n";

    for (PetData pet : petData) {
        writer << "\t" << titleToCamelCase(pet.internalName) << ": {\n";

        // Pet name
        generateObjectProperty(writer, 2, "name", pet.externalName, true);

        // Idle sprite paths
        generateSpritePaths(writer, pet, "idle", pet.idleSpriteCount);

        // Move sprite paths
        generateSpritePaths(writer, pet, "move", pet.moveSpriteCount);

        std::string thumbnailSpriteType = pet.thumbnailSprite.substr(0, pet.thumbnailSprite.find(' '));
        int thumbnailSpriteFrameNumber = std::stoi(pet.thumbnailSprite.substr(pet.thumbnailSprite.find(' ') + 1));
        generateObjectProperty(writer, 0, "thumbnailSprite", getSpritePath(pet, thumbnailSpriteType, thumbnailSpriteFrameNumber));

        generateObjectProperty(writer, 2, "activeLevel", pet.activeLevel);

        // Length of each frame
        generateObjectProperty(writer, 2, "idleFrameLengthMs", pet.idleFrameLengthMs);
        generateObjectProperty(writer, 2, "moveFrameLengthMs", pet.moveFrameLengthMs);

        generateObjectProperty(writer, 2, "moveSpeed", pet.moveSpeed);

        writer << "\t},\n";
    }

    writer << "};\n";
}

template <typename T>
void generateObjectProperty(std::ofstream& writer, unsigned indentationAmount, std::string key, T value, bool isString) {
    while (indentationAmount--) {
        writer << "\t";
    }
    writer << key << ": ";
    if (isString) {
        writer << '"';
    }
    writer << value;
    if (isString) {
        writer << '"';
    }
    writer << ",\n";
}

void generateSpritePaths(std::ofstream& writer, const PetData& pet, const std::string& spriteType, int spriteCount) {
    writer << "\t\t" << spriteType << "Sprites: [\n";
    for (unsigned i = 1; i <= spriteCount; ++i) {
        writer << getSpritePath(pet, spriteType, i) << ",\n";
    }
    writer << "\t\t],\n";
}

std::string getSpritePath(const PetData& pet, const std::string& spriteType, int frameNumber) {
    /* writer << "\t\t\tbrowser.runtime.getURL(\"/sprites/pet_sprites/" << toSnakeCase(pet.internalName) << "/" << spriteType << "/" << toSnakeCase(pet.internalName, true) << "_" << toSnakeCase(spriteType, true) << "_" << frameNumber << ".png\"),\n"; */
    return std::string() + "\t\t\tbrowser.runtime.getURL(\"/sprites/pet_sprites/" + toSnakeCase(pet.internalName) + "/" + spriteType + "/" + toSnakeCase(pet.internalName, true) + "_" + toSnakeCase(spriteType, true) + "_" + std::to_string(frameNumber) + ".png\")";
}

void generateSpriteDataTypes(std::ofstream& writer) {
    writer << "export type SinglePetData = {\n";

    generateObjectProperty(writer, 1, "name", "string");
    generateObjectProperty(writer, 1, "idleSprites", "string[]");
    generateObjectProperty(writer, 1, "moveSprites", "string[]");
    generateObjectProperty(writer, 1, "thumbnailSprite", "string");
    generateObjectProperty(writer, 1, "activeLevel", "number");
    generateObjectProperty(writer, 1, "idleFrameLengthMs", "number");
    generateObjectProperty(writer, 1, "moveFrameLengthMs", "number");
    generateObjectProperty(writer, 1, "moveSpeed", "number");

    writer << "}\n\n";
}